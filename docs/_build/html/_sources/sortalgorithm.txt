.. _sortalgorithm:


sort algorithm
==============

十大排序算法

* bubble sort(冒泡排序)

    方法: 始终是相邻的两个比较.
    实现: 用第0个和第1个比较，如果第0个大就交换位置...用倒数第二个和最后一个比较，如果倒数第二个大就交换位置。
    第一轮就是从前往后相邻的比较，最大的数就在最后一个位置。
    用第0个和第一个比较，如果第0个大就交换位置...用倒数第三个和倒数第二个比较，如果倒数第三个大就交换位置。
    第二轮就是从前到倒数第二个相邻的比较，第二大的就在倒数第二位置。
    ...
    依次类推，最后第0个和第1个比较。

    时间复杂度: O(n<sup>2</sup>)
    空间复杂度: O(1)

* selection sort(选择排序)

    方法: 从所有序列中选出最值放到第一个位置,然后从剩下的选出最值放到第二个位置,以此类推.
    实现: 默认下标为0的位置是最值,然后用这个位置的值和后面的依次比较,如果发现真的最值,就把这个值所在的下标设置新的最值下标.
    第一轮比较晚之后获取第一个最值,然后和第0个值交换,这样真的最值就在第一个位置.
    ...
    依次类推,直到倒数第二个和最后一个比较。

    时间复杂度: O(n<sup>2</sup>)
    空间复杂度: O(1)

* insertion sort(插入排序)

    时间复杂度: O(n<sup>2</sup>)

* shell sort(希尔排序)

    时间复杂度: O(n<sup>2</sup>)

* quick sort(快速排序)

    快速排序是冒泡排序的升级版,是目前速度最快的排序.

    时间复杂度: O(n<sup>2</sup>) 到 O(n*logn)

* merge sort(归并排序)

    时间复杂度: O(n*logn)

* heap sort(堆排序)

    堆排序也叫二叉树排序.

    时间复杂度: O(n*logn)

* radix sort(基数排序)

    基数排序,计数排序,桶排序三种排序都是非比较排序.

    时间复杂度: O(n)

* counting sort(计数排序)

    时间复杂度: O(n)

* bucket sort(桶排序)

    时间复杂度: O(n)
